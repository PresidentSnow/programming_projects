#!/bin/bash

# Función para mostrar mensajes de bienvenida
show_welcome() {
    echo "---"
    echo "Welcome to the IPv4 Subnetting Calculator"
    echo "---"
    echo " "
}

# Expresiones regulares para validación
REGEX_IP='^([0-9]{1,3}\.){3}[0-9]{1,3}$'
REGEX_CIDR='^[0-9]{1,2}$'

# Función para validar IPv4
validate_ip() {
    local ip=$1
    if [[ $ip =~ $REGEX_IP ]]; then
        IFS='.' read -r o1 o2 o3 o4 <<< "$ip"
        for octet in $o1 $o2 $o3 $o4; do
            if [[ $octet -lt 0 || $octet -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

# Función para validar CIDR
validate_cidr() {
    [[ $1 =~ $REGEX_CIDR ]] && [ $1 -ge 0 ] && [ $1 -le 32 ]
}

# Función para clasificar la IP
classify_ip() {
    local ip=$1
    
    # Expresiones regulares para clasificación
    REGEX_LOOPBACK='^127\.'
    REGEX_PRIVATE_A='^10\.'
    REGEX_PRIVATE_B='^172\.(1[6-9]|2[0-9]|3[0-1])\.'
    REGEX_PRIVATE_C='^192\.168\.'
    
    if [[ $ip =~ $REGEX_LOOPBACK ]]; then
        echo "Loopback (127.0.0.0/8)"
    elif [[ $ip =~ $REGEX_PRIVATE_A ]]; then
        echo "Private Class A (10.0.0.0/8)"
    elif [[ $ip =~ $REGEX_PRIVATE_B ]]; then
        echo "Private Class B (172.16.0.0/12)"
    elif [[ $ip =~ $REGEX_PRIVATE_C ]]; then
        echo "Private Class C (192.168.0.0/16)"
    else
        IFS='.' read -r o1 _ _ _ <<< "$ip"
        if [[ $o1 -le 126 ]]; then
            echo "Public Class A"
        elif [[ $o1 -le 191 ]]; then
            echo "Public Class B"
        elif [[ $o1 -le 223 ]]; then
            echo "Public Class C"
        elif [[ $o1 -le 239 ]]; then
            echo "Class D (Multicast)"
        else
            echo "Class E (Experimental)"
        fi
    fi
}

# Función para obtener entrada del usuario
get_user_input() {
    # Obtener dirección IP
    while true; do
        read -p "Enter the IPv4 address (e.g., 192.168.1.0): " ip
        if validate_ip "$ip"; then
            break
        else
            echo "Error: Invalid IPv4 address. Format should be like 192.168.1.0"
        fi
    done
    
    # Obtener CIDR
    while true; do
        read -p "Enter the CIDR notation (e.g., 24 for /24): " cidr
        if validate_cidr "$cidr"; then
            break
        else
            echo "Error: CIDR must be an integer between 0 and 32"
        fi
    done
    
    # Obtener número de subredes
    while true; do
        read -p "Enter the number of subnets you want to create: " num_subnets
        if [[ $num_subnets =~ ^[0-9]+$ ]] && [ $num_subnets -ge 1 ]; then
            break
        else
            echo "Error: Please enter a positive integer"
        fi
    done
    
    echo "$ip $cidr $num_subnets"
}

# Función principal
main() {
    show_welcome
    
    # Obtener entrada del usuario
    read ip cidr num_subnets <<< $(get_user_input)
    
    # Mostrar información de la IP
    echo "---"
    echo "IP Information:"
    echo "---"
    echo "IP Address: $ip"
    echo "IP Class: $(classify_ip "$ip")"
    echo "CIDR: /$cidr"
    echo "Subnets: $num_subnets"
    echo ""
    
    # Aquí iría la lógica de subnetting
    echo "Subnetting functionality will be implemented here"
    echo "Network: $ip/$cidr"
    echo "Number of subnets: $num_subnets"
}

# Ejecutar el script
main